"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bignumber_js_1 = require("bignumber.js");
const accounts_1 = require("./accounts");
const routing_table_1 = require("./routing-table");
const rate_backend_1 = require("./rate-backend");
const quoter_1 = require("./quoter");
const config_1 = require("./config");
const liquidity_curve_1 = require("../routing/liquidity-curve");
const IlpPacket = require("ilp-packet");
const log_1 = require("../common/log");
const log = log_1.create('route-builder');
const { BadRequestError, InsufficientTimeoutError, InvalidAmountError, InvalidPacketError, PeerUnreachableError, UnreachableError } = IlpPacket.Errors;
const PROBE_AMOUNT = new bignumber_js_1.default(10).pow(14).toNumber();
function rateToCurve(rate) {
    if (rate > 1) {
        return new liquidity_curve_1.default([[0, 0], [PROBE_AMOUNT / rate, PROBE_AMOUNT]]);
    }
    else {
        return new liquidity_curve_1.default([[0, 0], [PROBE_AMOUNT, PROBE_AMOUNT * rate]]);
    }
}
class RouteBuilder {
    constructor(deps) {
        this.accounts = deps(accounts_1.default);
        this.routingTable = deps(routing_table_1.default);
        this.backend = deps(rate_backend_1.default);
        this.quoter = deps(quoter_1.default);
        this.config = deps(config_1.default);
        this.isTrivialRate =
            this.config.backend === 'one-to-one' &&
                this.config.spread === 0;
    }
    getNextHop(sourceAccount, destinationAccount) {
        const route = this.routingTable.resolve(destinationAccount);
        if (!route) {
            log.info('no route found for quote. destinationAccount=' + destinationAccount);
            throw new UnreachableError('no route found. to=' + destinationAccount);
        }
        if (!this.config.reflectPayments && sourceAccount === route.nextHop) {
            log.info('refusing to route payments back to sender. sourceAccount=%s destinationAccount=%s', sourceAccount, destinationAccount);
            throw new UnreachableError('refusing to route payments back to sender. sourceAccount=' + sourceAccount + ' destinationAccount=' + destinationAccount);
        }
        return route.nextHop;
    }
    async quoteLocal(sourceAccount, destinationAccount) {
        if (!this.accounts.getAssetCode(sourceAccount)) {
            log.info('source account is unavailable. sourceAccount=' + sourceAccount);
            throw new UnreachableError('no route from source. sourceAccount=' + sourceAccount);
        }
        const nextHop = this.getNextHop(sourceAccount, destinationAccount);
        if (!this.accounts.getAssetCode(nextHop)) {
            log.info('next hop is unavailable. nextHop=' + nextHop);
            throw new UnreachableError('no route to next hop. nextHop=' + nextHop);
        }
        log.debug('determined next hop. nextHop=' + nextHop);
        const rate = await this.backend.getRate(sourceAccount, nextHop);
        log.debug('determined local rate. rate=' + rate);
        return { nextHop, rate };
    }
    async quoteLiquidity(sourceAccount, packet) {
        log.info('creating liquidity quote. sourceAccount=%s destinationAccount=%s', sourceAccount, packet.destinationAccount);
        const { nextHop, rate } = await this.quoteLocal(sourceAccount, packet.destinationAccount);
        const localQuoteExpiry = Date.now() + (this.config.quoteExpiry);
        const localCurve = rateToCurve(rate);
        let liquidityCurve;
        let appliesToPrefix;
        let sourceHoldDuration;
        let expiresAt;
        if (packet.destinationAccount.startsWith(nextHop)) {
            log.debug('local destination.');
            liquidityCurve = localCurve;
            appliesToPrefix = nextHop;
            sourceHoldDuration = packet.destinationHoldDuration + this.config.minMessageWindow;
            expiresAt = localQuoteExpiry;
        }
        else {
            const quote = await this.quoter.quoteLiquidity(nextHop, packet.destinationAccount);
            if (!quote) {
                log.info('no quote found. sourceAccount=%s params=%j', sourceAccount, packet);
                throw new UnreachableError('no quote found. to=' + packet.destinationAccount);
            }
            log.debug('remote destination. quote=%j', quote);
            liquidityCurve = localCurve.join(quote.curve);
            appliesToPrefix = quote.prefix;
            sourceHoldDuration = packet.destinationHoldDuration + quote.minMessageWindow + this.config.minMessageWindow;
            expiresAt = Math.min(Number(quote.expiry), localQuoteExpiry);
        }
        this._verifyPluginIsConnected(nextHop);
        this._validateHoldDurations(sourceHoldDuration, packet.destinationHoldDuration);
        const shiftBy = this._getScaleAdjustment(sourceAccount, nextHop);
        return {
            liquidityCurve: liquidityCurve.shiftX(shiftBy).toBuffer(),
            appliesToPrefix: this.routingTable.getShortestUnambiguousPrefix(packet.destinationAccount, appliesToPrefix),
            sourceHoldDuration,
            expiresAt: new Date(expiresAt)
        };
    }
    _getScaleAdjustment(sourceAccount, destinationAccount) {
        const sourceScale = this.accounts.getInfo(sourceAccount).assetScale;
        const destinationScale = this.accounts.getInfo(destinationAccount).assetScale;
        if (sourceScale === destinationScale && this.isTrivialRate)
            return 0;
        return 1;
    }
    async quoteBySource(sourceAccount, packet) {
        log.info('creating quote by source amount. sourceAccount=%s destinationAccount=%s sourceAmount=%s', sourceAccount, packet.destinationAccount, packet.sourceAmount);
        if (packet.sourceAmount === '0') {
            throw new InvalidAmountError('sourceAmount must be positive');
        }
        const { nextHop, rate } = await this.quoteLocal(sourceAccount, packet.destinationAccount);
        const nextAmount = new bignumber_js_1.default(packet.sourceAmount).times(rate).integerValue(bignumber_js_1.default.ROUND_FLOOR).toString();
        let destinationAmount;
        let sourceHoldDuration;
        if (packet.destinationAccount.startsWith(nextHop)) {
            log.debug('local destination. destinationAmount=' + nextAmount);
            destinationAmount = nextAmount;
            sourceHoldDuration = packet.destinationHoldDuration + this.config.minMessageWindow;
        }
        else {
            const quote = await this.quoter.quoteLiquidity(nextHop, packet.destinationAccount);
            if (!quote) {
                log.info('no quote found. sourceAccount=%s params=%j', sourceAccount, packet);
                throw new UnreachableError('no quote found. to=' + packet.destinationAccount);
            }
            log.debug('remote destination. quote=%j', quote);
            destinationAmount = quote.curve.amountAt(packet.sourceAmount).times(rate).integerValue(bignumber_js_1.default.ROUND_FLOOR).toString();
            sourceHoldDuration = packet.destinationHoldDuration + quote.minMessageWindow + this.config.minMessageWindow;
        }
        if (destinationAmount === '0') {
            throw new InvalidAmountError('quoted destination is lower than minimum amount allowed.');
        }
        this._verifyPluginIsConnected(sourceAccount);
        this._verifyPluginIsConnected(nextHop);
        this._validateHoldDurations(sourceHoldDuration, packet.destinationHoldDuration);
        return {
            destinationAmount,
            sourceHoldDuration
        };
    }
    async quoteByDestination(sourceAccount, packet) {
        log.info('creating quote by destination amount. sourceAccount=%s destinationAccount=%s destinationAmount=%s', sourceAccount, packet.destinationAccount, packet.destinationAmount);
        if (packet.destinationAmount === '0') {
            throw new InvalidAmountError('destinationAmount must be positive');
        }
        const { nextHop, rate } = await this.quoteLocal(sourceAccount, packet.destinationAccount);
        let nextHopAmount;
        let nextHopHoldDuration;
        if (packet.destinationAccount.startsWith(nextHop)) {
            log.debug('local destination.');
            nextHopAmount = packet.destinationAmount;
            nextHopHoldDuration = packet.destinationHoldDuration;
        }
        else {
            const quote = await this.quoter.quoteLiquidity(nextHop, packet.destinationAccount);
            if (!quote) {
                log.info('no quote found. sourceAccount=%s params=%j', sourceAccount, packet);
                throw new UnreachableError('no quote found. to=' + packet.destinationAccount);
            }
            log.debug('remote destination. quote=%j', quote);
            nextHopAmount = quote.curve.amountReverse(packet.destinationAmount).toString();
            nextHopHoldDuration = packet.destinationHoldDuration + quote.minMessageWindow;
        }
        const sourceAmount = new bignumber_js_1.default(nextHopAmount).div(rate).integerValue(bignumber_js_1.default.ROUND_CEIL).toString();
        const sourceHoldDuration = nextHopHoldDuration + this.config.minMessageWindow;
        if (sourceAmount === '0') {
            throw new InvalidAmountError('Quoted source is lower than minimum amount allowed');
        }
        this._verifyPluginIsConnected(sourceAccount);
        this._verifyPluginIsConnected(nextHop);
        this._validateHoldDurations(sourceHoldDuration, packet.destinationHoldDuration);
        return {
            sourceAmount,
            sourceHoldDuration
        };
    }
    async getNextHopPacket(sourceAccount, sourcePacket) {
        const { amount, executionCondition, expiresAt, destination, data } = sourcePacket;
        log.info('constructing next hop packet. sourceAccount=%s sourceAmount=%s destination=%s', sourceAccount, amount, destination);
        if (destination.length < 1) {
            throw new InvalidPacketError('missing destination.');
        }
        const route = this.routingTable.resolve(destination);
        if (!route) {
            log.info('could not find route for transfer. sourceAccount=%s sourceAmount=%s destinationAccount=%s', sourceAccount, amount, destination);
            throw new UnreachableError('no route found. source=' + sourceAccount + ' destination=' + destination);
        }
        const nextHop = route.nextHop;
        log.debug('determined next hop. nextHop=%s', nextHop);
        const rate = await this.backend.getRate(sourceAccount, nextHop);
        log.debug('determined local rate. rate=%s', rate);
        this._verifyPluginIsConnected(nextHop);
        const nextAmount = new bignumber_js_1.default(amount).times(rate).integerValue(bignumber_js_1.default.ROUND_FLOOR);
        return {
            nextHop,
            nextHopPacket: {
                amount: nextAmount.toString(),
                expiresAt: this._getDestinationExpiry(expiresAt),
                executionCondition,
                destination,
                data
            }
        };
    }
    _validateHoldDurations(sourceHoldDuration, destinationHoldDuration) {
        if (destinationHoldDuration > this.config.maxHoldTime) {
            throw new BadRequestError('destination expiry duration ' +
                'is too long. destinationHoldDuration=' + destinationHoldDuration +
                ' maxHoldTime=' + this.config.maxHoldTime);
        }
        if (sourceHoldDuration - destinationHoldDuration < this.config.minMessageWindow) {
            throw new BadRequestError('the difference between the ' +
                'destination expiry duration and the source expiry duration ' +
                'is insufficient to ensure that we can execute the ' +
                'source transfers.');
        }
    }
    _getDestinationExpiry(sourceExpiry) {
        if (!sourceExpiry) {
            throw new TypeError('source expiry must be a Date');
        }
        const sourceExpiryTime = sourceExpiry.getTime();
        if (sourceExpiryTime < Date.now()) {
            throw new InsufficientTimeoutError('source transfer has already expired. sourceExpiry=' + sourceExpiry.toISOString() + ' currentTime=' + (new Date().toISOString()));
        }
        const destinationExpiryTime = Math.min(sourceExpiryTime - this.config.minMessageWindow, Date.now() + this.config.maxHoldTime);
        if ((destinationExpiryTime - Date.now()) < this.config.minMessageWindow) {
            throw new InsufficientTimeoutError('source transfer expires too soon to complete payment. actualSourceExpiry=' + sourceExpiry.toISOString() + ' requiredSourceExpiry=' + (new Date(Date.now() + 2 * this.config.minMessageWindow).toISOString()) + ' currentTime=' + (new Date().toISOString()));
        }
        return new Date(destinationExpiryTime);
    }
    _verifyPluginIsConnected(account) {
        if (!this.accounts.getPlugin(account).isConnected()) {
            throw new PeerUnreachableError('no connection to account. account=' + account);
        }
    }
}
exports.default = RouteBuilder;
//# sourceMappingURL=route-builder.js.map