{"version":3,"file":"throughput.js","sourceRoot":"","sources":["throughput.ts"],"names":[],"mappings":"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","sourcesContent":["import { create as createLogger } from '../common/log'\nconst log = createLogger('throughput-middleware')\nimport { Middleware, MiddlewareCallback, MiddlewareServices, Pipelines } from '../types/middleware'\nimport { AccountInfo } from '../types/accounts'\nimport TokenBucket from '../lib/token-bucket'\nimport * as IlpPacket from 'ilp-packet'\nconst { InsufficientLiquidityError } = IlpPacket.Errors\n\nconst DEFAULT_REFILL_PERIOD = 1000 // 1 second\n\nexport default class ThroughputMiddleware implements Middleware {\n  private getInfo: (accountId: string) => AccountInfo\n\n  constructor (opts: {}, { getInfo }: MiddlewareServices) {\n    this.getInfo = getInfo\n  }\n\n  async applyToPipelines (pipelines: Pipelines, accountId: string) {\n    const accountInfo = this.getInfo(accountId)\n    if (!accountInfo) {\n      throw new Error('could not load info for account. accountId=' + accountId)\n    }\n\n    if (accountInfo.throughput) {\n      const {\n        refillPeriod = DEFAULT_REFILL_PERIOD,\n        incomingAmount = false,\n        outgoingAmount = false\n      } = accountInfo.throughput || {}\n\n      if (incomingAmount) {\n        // TODO: When we add the ability to update middleware, our state will get\n        //   reset every update, which may not be desired.\n        const incomingBucket = new TokenBucket({ refillPeriod, refillCount: Number(incomingAmount) })\n        log.debug('created incoming amount limit token bucket for account. accountId=%s refillPeriod=%s incomingAmount=%s', accountId, refillPeriod, incomingAmount)\n\n        pipelines.incomingData.insertLast({\n          name: 'throughput',\n          method: async (data: Buffer, next: MiddlewareCallback<Buffer, Buffer>) => {\n            if (data[0] === IlpPacket.Type.TYPE_ILP_PREPARE) {\n              const parsedPacket = IlpPacket.deserializeIlpPrepare(data)\n\n              // TODO: Do we need a BigNumber-based token bucket?\n              if (!incomingBucket.take(Number(parsedPacket.amount))) {\n                throw new InsufficientLiquidityError('exceeded money bandwidth, throttling.')\n              }\n\n              return next(data)\n            } else {\n              return next(data)\n            }\n          }\n        })\n      }\n\n      if (outgoingAmount) {\n        // TODO: When we add the ability to update middleware, our state will get\n        //   reset every update, which may not be desired.\n        const incomingBucket = new TokenBucket({ refillPeriod, refillCount: Number(outgoingAmount) })\n        log.debug('created outgoing amount limit token bucket for account. accountId=%s refillPeriod=%s outgoingAmount=%s', accountId, refillPeriod, outgoingAmount)\n\n        pipelines.outgoingData.insertLast({\n          name: 'throughput',\n          method: async (data: Buffer, next: MiddlewareCallback<Buffer, Buffer>) => {\n            if (data[0] === IlpPacket.Type.TYPE_ILP_PREPARE) {\n              const parsedPacket = IlpPacket.deserializeIlpPrepare(data)\n\n              // TODO: Do we need a BigNumber-based token bucket?\n              if (!incomingBucket.take(Number(parsedPacket.amount))) {\n                throw new InsufficientLiquidityError('exceeded money bandwidth, throttling.')\n              }\n\n              return next(data)\n            } else {\n              return next(data)\n            }\n          }\n        })\n      }\n    }\n  }\n}\n"]}