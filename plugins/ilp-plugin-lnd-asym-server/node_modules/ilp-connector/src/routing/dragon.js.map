{"version":3,"file":"dragon.js","sourceRoot":"","sources":["dragon.ts"],"names":[],"mappings":";;AACA,uCAAsD;AACtD,MAAM,GAAG,GAAG,YAAY,CAAC,QAAQ,CAAC,CAAA;AAClC,yCAA0D;AA6B1D,yBACE,YAAoC,EACpC,WAAyC,EACzC,MAAc,EACd,KAAY;IAGZ,GAAG,CAAC,CAAC,MAAM,YAAY,IAAI,YAAY,CAAC,iBAAiB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QAClE,MAAM,iBAAiB,GAAG,YAAY,CAAC,GAAG,CAAC,YAAY,CAAC,CAAA;QAExD,EAAE,CAAC,CAAC,CAAC,iBAAiB,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC,CAAC;YACnD,GAAG,CAAC,IAAI,CAAC,iGAAiG,EAAE,MAAM,EAAE,YAAY,CAAC,CAAA;YACjI,QAAQ,CAAA;QACV,CAAC;QAED,MAAM,WAAW,GAAG,iBAAiB,CAAC,KAAK,CAAA;QAE3C,EAAE,CAAC,CAAC,WAAW,CAAC,OAAO,KAAK,EAAE,CAAC,CAAC,CAAC;YAE/B,QAAQ,CAAA;QACV,CAAC;QAED,MAAM,cAAc,GAAG,WAAW,CAAC,WAAW,CAAC,OAAO,CAAC,CAAA;QACvD,MAAM,aAAa,GAAG,WAAW,CAAC,KAAK,CAAC,OAAO,CAAC,CAAA;QAChD,EAAE,CAAC,CAAC,8BAAmB,CAAC,cAAc,CAAC,GAAG,8BAAmB,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;YAE7E,QAAQ,CAAA;QACV,CAAC;QAED,GAAG,CAAC,KAAK,CAAC,wDAAwD,EAAE,MAAM,EAAE,YAAY,CAAC,CAAA;QACzF,MAAM,CAAC,IAAI,CAAA;IACb,CAAC;IAED,MAAM,CAAC,KAAK,CAAA;AACd,CAAC;AAlCD,0CAkCC","sourcesContent":["import { Route } from '../types/routing'\nimport { create as createLogger } from '../common/log'\nconst log = createLogger('dragon')\nimport { Relation, getRelationPriority } from './relation'\nimport ForwardingRoutingTable from '../services/forwarding-routing-table'\n\n/**\n * Check whether a route can be filtered out based on DRAGON rules.\n *\n * See http://route-aggregation.net/.\n *\n * The basic idea is that if we have a more general route that is as good as a\n * more specific route, we don't need to advertise the more specific route.\n *\n * This removes a lot of routing update across a large network and has basically\n * no downside.\n *\n * Note that we use DRAGON filtering, but *not* DRAGON aggregation. There are\n * several reasons for this:\n *\n *  * ILP address space is a lot less dense than IPv4 address space, so\n *    DRAGON aggregation would not be a significant optimization.\n *\n *  * We may want to secure our routing protocol using a mechanism similar to\n *    BGPsec, which precludes aggregation.\n *\n *  * We will recommend that owners of tier-1 ILP address space are also real\n *    connectors which participate in the routing protocol and originate a route\n *    advertisement for their tier-1 prefix. This will enable DRAGON filtering\n *    to apply to a lot more situations where otherwise only DRAGON aggregation\n *    would be applicable.\n */\nexport function canDragonFilter (\n  routingTable: ForwardingRoutingTable,\n  getRelation: (prefix: string) => Relation,\n  prefix: string,\n  route: Route\n): boolean {\n  // Find any less specific route\n  for (const parentPrefix of routingTable.getKeysPrefixesOf(prefix)) {\n    const parentRouteUpdate = routingTable.get(parentPrefix)\n\n    if (!parentRouteUpdate || !parentRouteUpdate.route) {\n      log.warn('found a parent prefix, but no parent route; this should never happen. prefix=%s parentPrefix=%s', prefix, parentPrefix)\n      continue\n    }\n\n    const parentRoute = parentRouteUpdate.route\n\n    if (parentRoute.nextHop === '') {\n      // We are the origin of the parent route, cannot DRAGON filter\n      continue\n    }\n\n    const parentRelation = getRelation(parentRoute.nextHop)\n    const childRelation = getRelation(route.nextHop)\n    if (getRelationPriority(parentRelation) < getRelationPriority(childRelation)) {\n      // The more specific route is better for us, so we keep it\n      continue\n    }\n\n    log.debug('applied DRAGON route filter. prefix=%s parentPrefix=%s', prefix, parentPrefix)\n    return true\n  }\n\n  return false\n}\n"]}