import Accounts from '../services/accounts';
import ForwardingRoutingTable from '../services/forwarding-routing-table';
import { BroadcastRoute } from '../types/routing';
import { Relation } from './relation';
import { CcpRouteControlRequest, Mode } from 'ilp-protocol-ccp';
import { PluginInstance } from '../types/plugin';
export interface BroadcastRoutesParams {
    accounts: Accounts;
    newRoutes: BroadcastRoute[];
    routingTableId: string;
    holdDownTime: number;
    withdrawnRoutes: {
        prefix: string;
        epoch: number;
    }[];
    fromEpoch: number;
    toEpoch: number;
    timeout: number;
}
export interface CcpSenderOpts {
    accountId: string;
    plugin: PluginInstance;
    forwardingRoutingTable: ForwardingRoutingTable;
    getOwnAddress: () => string;
    getAccountRelation: (accountId: string) => Relation;
    routeExpiry: number;
    routeBroadcastInterval: number;
}
export default class CcpSender {
    private plugin;
    private forwardingRoutingTable;
    private log;
    private accountId;
    private mode;
    private getOwnAddress;
    private getAccountRelation;
    private routeExpiry;
    private routeBroadcastInterval;
    private lastKnownEpoch;
    private lastUpdate;
    private sendRouteUpdateTimer?;
    constructor({accountId, plugin, forwardingRoutingTable, getOwnAddress, getAccountRelation, routeExpiry, routeBroadcastInterval}: CcpSenderOpts);
    stop(): void;
    getAccountId(): string;
    getLastUpdate(): number;
    getLastKnownEpoch(): number;
    getMode(): Mode;
    getStatus(): {
        epoch: number;
        mode: string;
    };
    handleRouteControl({mode, lastKnownRoutingTableId, lastKnownEpoch, features}: CcpRouteControlRequest): void;
    scheduleRouteUpdate: () => void;
    private sendSingleRouteUpdate();
}
