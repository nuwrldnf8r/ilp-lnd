{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":"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","sourcesContent":["import * as IlpPacket from 'ilp-packet'\nimport { Reader, Writer } from 'oer-utils'\nimport { readUuid, writeUuid } from './uuid'\n\nexport const CCP_CONTROL_DESTINATION = 'peer.route.control'\nexport const CCP_UPDATE_DESTINATION = 'peer.route.update'\nexport const PEER_PROTOCOL_FULFILLMENT = Buffer.alloc(32)\nexport const PEER_PROTOCOL_CONDITION = Buffer.from('Zmh6rfhivXdsj8GLjp+OIAiXFIVu4jOzkCpZHQ1fKSU=', 'base64')\nconst PEER_PROTOCOL_EXPIRY_DURATION = 60000\n\nexport enum Mode {\n  MODE_IDLE = 0,\n  MODE_SYNC = 1\n}\n\nexport const ModeReverseMap = ['IDLE', 'SYNC']\n\nexport interface CcpRouteControlRequest {\n  mode: Mode.MODE_IDLE | Mode.MODE_SYNC\n  lastKnownRoutingTableId: string\n  lastKnownEpoch: number\n  features: string[]\n}\n\nexport interface CcpRouteControlResponse {\n  // empty\n}\n\n// Well-known route property IDs\nexport enum PropId {\n}\n\nexport interface CcpRoutePropCommon {\n  isOptional: boolean\n  isTransitive: boolean\n  isPartial: boolean\n}\n\nexport interface CcpRoutePropBuffer extends CcpRoutePropCommon {\n  isUtf8: false\n  id: number\n  value: Buffer\n}\n\nexport interface CcpRoutePropString extends CcpRoutePropCommon {\n  isUtf8: true\n  id: number\n  value: string\n}\n\nexport type CcpRouteProp =\n  // Generic props\n  CcpRoutePropBuffer |\n  CcpRoutePropString\n\nexport interface CcpRoute {\n  prefix: string\n  path: string[]\n  auth: Buffer\n  props: CcpRouteProp[]\n}\n\nexport interface CcpRouteUpdateRequest {\n  routingTableId: string\n  currentEpochIndex: number\n  fromEpochIndex: number\n  toEpochIndex: number\n  holdDownTime: number\n  speaker: string\n  newRoutes: CcpRoute[]\n  withdrawnRoutes: string[]\n}\n\nexport interface CcpRouteUpdateResponse {\n  // empty\n}\n\nconst deserializeCcpRouteControlRequest = (request: Buffer): CcpRouteControlRequest => {\n  const ilp = IlpPacket.deserializeIlpPrepare(request)\n\n  if (ilp.destination !== CCP_CONTROL_DESTINATION) {\n    throw new TypeError('packet is not a CCP route control request.')\n  }\n\n  if (!PEER_PROTOCOL_CONDITION.equals(ilp.executionCondition)) {\n    throw new Error('packet does not contain correct condition for a peer protocol request.')\n  }\n\n  if (Date.now() > Number(ilp.expiresAt)) {\n    throw new Error('CCP route control request packet is expired.')\n  }\n\n  const reader = new Reader(ilp.data)\n\n  const mode = reader.readUInt8()\n\n  const lastKnownRoutingTableId = readUuid(reader)\n\n  const lastKnownEpoch = reader.readUInt32()\n\n  const featureCount = reader.readVarUInt()\n  const features = []\n  for (let i = 0; i < featureCount; i++) {\n    features.push(reader.readVarOctetString().toString('utf8'))\n  }\n\n  return {\n    mode,\n    lastKnownRoutingTableId,\n    lastKnownEpoch,\n    features\n  }\n}\n\nconst serializeCcpRouteControlRequest = (request: CcpRouteControlRequest): Buffer => {\n  const writer = new Writer()\n\n  writer.writeUInt8(request.mode)\n\n  writeUuid(writer, request.lastKnownRoutingTableId)\n\n  writer.writeUInt32(request.lastKnownEpoch)\n\n  writer.writeVarUInt(request.features.length)\n\n  for (const feature of request.features) {\n    writer.writeVarOctetString(Buffer.from(feature, 'utf8'))\n  }\n\n  return IlpPacket.serializeIlpPrepare({\n    amount: '0',\n    destination: CCP_CONTROL_DESTINATION,\n    executionCondition: PEER_PROTOCOL_CONDITION,\n    expiresAt: new Date(Date.now() + PEER_PROTOCOL_EXPIRY_DURATION),\n    data: writer.getBuffer()\n  })\n}\n\nconst deserializeCcpRouteUpdateRequest = (request: Buffer): CcpRouteUpdateRequest => {\n  const ilp = IlpPacket.deserializeIlpPrepare(request)\n\n  if (ilp.destination !== CCP_UPDATE_DESTINATION) {\n    throw new TypeError('packet is not a CCP route update request.')\n  }\n\n  if (!PEER_PROTOCOL_CONDITION.equals(ilp.executionCondition)) {\n    throw new Error('packet does not contain correct condition for a peer protocol request.')\n  }\n\n  if (Date.now() > Number(ilp.expiresAt)) {\n    throw new Error('CCP route update request packet is expired.')\n  }\n\n  const reader = new Reader(ilp.data)\n\n  const routingTableId = readUuid(reader)\n\n  const currentEpochIndex = reader.readUInt32()\n\n  const fromEpochIndex = reader.readUInt32()\n\n  const toEpochIndex = reader.readUInt32()\n\n  const holdDownTime = reader.readUInt32()\n\n  const speaker = reader.readVarOctetString().toString('ascii')\n\n  const newRoutesCount = reader.readVarUInt()\n  const newRoutes = []\n  for (let i = 0; i < newRoutesCount; i++) {\n    const prefix = reader.readVarOctetString().toString('ascii')\n\n    const pathLength = reader.readVarUInt()\n    const path = []\n    for (let i = 0; i < pathLength; i++) {\n      path.push(reader.readVarOctetString().toString('ascii'))\n    }\n\n    const auth = reader.read(32)\n\n    const propCount = reader.readVarUInt()\n    const props: CcpRouteProp[] = []\n    for (let i = 0; i < propCount; i++) {\n      const meta = reader.readUInt8()\n      const isOptional = Boolean(meta & 0x80)\n      const isTransitive = Boolean(meta & 0x40)\n      const isPartial = Boolean(meta & 0x20)\n      const isUtf8 = Boolean(meta & 0x10)\n\n      const id = reader.readUInt16()\n      const value = reader.readVarOctetString()\n\n      const incompleteProp = {\n        isOptional,\n        isTransitive,\n        isPartial,\n        id\n      }\n\n      if (isUtf8) {\n        props.push({\n          ...incompleteProp,\n          isUtf8: true,\n          value: value.toString('utf8')\n        })\n      } else {\n        props.push({\n          ...incompleteProp,\n          isUtf8: false,\n          value: value\n        })\n      }\n    }\n\n    newRoutes.push({\n      prefix,\n      path,\n      auth,\n      props\n    })\n  }\n\n  const withdrawnRoutesCount = reader.readVarUInt()\n  const withdrawnRoutes = []\n  for (let i = 0; i < withdrawnRoutesCount; i++) {\n    withdrawnRoutes.push(reader.readVarOctetString().toString('utf8'))\n  }\n\n  return {\n    routingTableId,\n    currentEpochIndex,\n    fromEpochIndex,\n    toEpochIndex,\n    holdDownTime,\n    speaker,\n    newRoutes,\n    withdrawnRoutes\n  }\n}\n\nconst serializeCcpRouteUpdateRequest = (request: CcpRouteUpdateRequest): Buffer => {\n  const writer = new Writer()\n\n  writeUuid(writer, request.routingTableId)\n\n  writer.writeUInt32(request.currentEpochIndex)\n  writer.writeUInt32(request.fromEpochIndex)\n  writer.writeUInt32(request.toEpochIndex)\n\n  writer.writeUInt32(request.holdDownTime)\n\n  writer.writeVarOctetString(Buffer.from(request.speaker, 'ascii'))\n\n  writer.writeVarUInt(request.newRoutes.length)\n  for (const route of request.newRoutes) {\n    writer.writeVarOctetString(Buffer.from(route.prefix, 'ascii'))\n\n    writer.writeVarUInt(route.path.length)\n    for (const hop of route.path) {\n      writer.writeVarOctetString(Buffer.from(hop, 'ascii'))\n    }\n\n    if (route.auth.length !== 32) {\n      throw new Error('route auth must be 32 bytes. prefix=' + route.prefix)\n    }\n    writer.write(route.auth)\n\n    writer.writeVarUInt(route.props.length)\n    for (const prop of route.props) {\n      let meta = 0\n\n      meta |= prop.isOptional ? 0x80 : 0\n\n      if (prop.isOptional) {\n        meta |= prop.isTransitive ? 0x40 : 0\n\n        if (prop.isTransitive) {\n          meta |= prop.isPartial ? 0x20 : 0\n        }\n      } else {\n        // Transitive bit must be set for well-known properties\n        meta |= 0x40\n      }\n\n      meta |= prop.isUtf8 ? 0x10 : 0\n\n      writer.writeUInt8(meta)\n\n      writer.writeUInt16(prop.id)\n\n      writer.writeVarOctetString(prop.isUtf8 ? Buffer.from(prop.value, 'utf8') : prop.value)\n    }\n  }\n\n  writer.writeVarUInt(request.withdrawnRoutes.length)\n  for (const route of request.withdrawnRoutes) {\n    writer.writeVarOctetString(Buffer.from(route, 'ascii'))\n  }\n\n  return IlpPacket.serializeIlpPrepare({\n    amount: '0',\n    destination: CCP_UPDATE_DESTINATION,\n    executionCondition: PEER_PROTOCOL_CONDITION,\n    expiresAt: new Date(Date.now() + PEER_PROTOCOL_EXPIRY_DURATION),\n    data: writer.getBuffer()\n  })\n}\n\nconst deserializeCcpResponse = (response: Buffer): void => {\n  const { fulfillment } = IlpPacket.deserializeIlpFulfill(response)\n\n  if (!PEER_PROTOCOL_FULFILLMENT.equals(fulfillment)) {\n    throw new Error('CCP response does not contain the expected fulfillment.')\n  }\n}\n\nconst serializeCcpResponse = (): Buffer => {\n  return IlpPacket.serializeIlpFulfill({\n    fulfillment: PEER_PROTOCOL_FULFILLMENT,\n    data: Buffer.alloc(0)\n  })\n}\n\nexport {\n  deserializeCcpRouteControlRequest,\n  serializeCcpRouteControlRequest,\n  deserializeCcpRouteUpdateRequest,\n  serializeCcpRouteUpdateRequest,\n  deserializeCcpResponse,\n  serializeCcpResponse\n}\n"]}