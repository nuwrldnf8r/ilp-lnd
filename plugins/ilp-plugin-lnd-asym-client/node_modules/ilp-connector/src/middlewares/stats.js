"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const IlpPacket = require("ilp-packet");
class StatsMiddleware {
    constructor(opts, { stats }) {
        this.stats = stats;
    }
    async applyToPipelines(pipelines, accountId) {
        pipelines.incomingData.insertLast({
            name: 'stats',
            method: this.makeDataMiddleware('stats/incomingData/' + accountId)
        });
        pipelines.incomingMoney.insertLast({
            name: 'stats',
            method: async (amount, next) => {
                this.stats.counter('stats/incomingMoney/' + accountId, +amount);
                return next(amount);
            }
        });
        pipelines.outgoingData.insertLast({
            name: 'stats',
            method: this.makeDataMiddleware('stats/outgoingData/' + accountId)
        });
        pipelines.outgoingMoney.insertLast({
            name: 'stats',
            method: async (amount, next) => {
                this.stats.counter('stats/outgoingMoney/' + accountId, +amount);
                return next(amount);
            }
        });
    }
    makeDataMiddleware(prefix) {
        return async (data, next) => {
            if (data[0] !== IlpPacket.Type.TYPE_ILP_PREPARE)
                return next(data);
            const { amount } = IlpPacket.deserializeIlpPrepare(data);
            if (amount === '0')
                return next(data);
            let result;
            try {
                result = await next(data);
            }
            catch (err) {
                this.stats.counter(prefix + '/failed', +amount);
                throw err;
            }
            if (result[0] === IlpPacket.Type.TYPE_ILP_FULFILL) {
                this.stats.counter(prefix + '/fulfilled', +amount);
            }
            else {
                this.stats.counter(prefix + '/rejected', +amount);
            }
            return result;
        };
    }
}
exports.default = StatsMiddleware;
//# sourceMappingURL=stats.js.map