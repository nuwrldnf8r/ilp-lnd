"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const IlpPacket = require("ilp-packet");
const bignumber_js_1 = require("bignumber.js");
const STATIC_DATA_OFFSET = 25;
const CACHE_CLEANUP_INTERVAL = 30000;
const PACKET_CACHE_DURATION = 30000;
class DeduplicateMiddleware {
    constructor() {
        this.packetCache = new Map();
    }
    async applyToPipelines(pipelines, accountId) {
        pipelines.startup.insertLast({
            name: 'deduplicate',
            method: async (dummy, next) => {
                setInterval(() => this.cleanupCache(), CACHE_CLEANUP_INTERVAL);
            }
        });
        pipelines.outgoingData.insertLast({
            name: 'deduplicate',
            method: async (data, next) => {
                if (data[0] === IlpPacket.Type.TYPE_ILP_PREPARE) {
                    const { contents } = IlpPacket.deserializeEnvelope(data);
                    const index = crypto_1.createHash('sha256')
                        .update(contents.slice(STATIC_DATA_OFFSET))
                        .digest()
                        .slice(0, 16)
                        .toString('base64');
                    const { amount, expiresAt } = IlpPacket.deserializeIlpPrepare(data);
                    const cachedPacket = this.packetCache.get(index);
                    if (cachedPacket) {
                        if (new bignumber_js_1.default(cachedPacket.amount).gte(amount) && cachedPacket.expiresAt >= expiresAt) {
                            return cachedPacket.promise;
                        }
                    }
                    const promise = next(data);
                    this.packetCache.set(index, {
                        amount,
                        expiresAt,
                        promise
                    });
                    return promise;
                }
                return next(data);
            }
        });
    }
    cleanupCache() {
        const now = Date.now();
        for (const index of this.packetCache.keys()) {
            const cachedPacket = this.packetCache.get(index);
            if (!cachedPacket)
                continue;
            const packetExpiry = cachedPacket.expiresAt.getTime() + PACKET_CACHE_DURATION;
            if (packetExpiry < now) {
                this.packetCache.delete(index);
            }
        }
    }
}
exports.default = DeduplicateMiddleware;
//# sourceMappingURL=deduplicate.js.map