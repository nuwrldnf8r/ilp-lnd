{"version":3,"file":"route-builder.js","sourceRoot":"","sources":["route-builder.ts"],"names":[],"mappings":"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","sourcesContent":["import BigNumber from 'bignumber.js'\nimport Accounts from './accounts'\nimport RoutingTable from './routing-table'\nimport RateBackend from './rate-backend'\nimport Quoter from './quoter'\nimport Config from './config'\nimport LiquidityCurve from '../routing/liquidity-curve'\nimport reduct = require('reduct')\nimport * as IlpPacket from 'ilp-packet'\nimport { create as createLogger } from '../common/log'\nconst log = createLogger('route-builder')\nconst {\n  BadRequestError,\n  InsufficientTimeoutError,\n  InvalidAmountError,\n  InvalidPacketError,\n  PeerUnreachableError,\n  UnreachableError\n} = IlpPacket.Errors\n\nconst PROBE_AMOUNT = new BigNumber(10).pow(14).toNumber() // stays within 15 max digits for BigNumber from Number\n\nfunction rateToCurve (rate: number) {\n  // Make sure that neither amount exceeds 15 significant digits.\n  if (rate > 1) {\n    return new LiquidityCurve([ [0, 0], [ PROBE_AMOUNT / rate, PROBE_AMOUNT ] ])\n  } else {\n    return new LiquidityCurve([ [0, 0], [ PROBE_AMOUNT, PROBE_AMOUNT * rate ] ])\n  }\n}\n\nexport interface QuoteLiquidityParams extends IlpPacket.IlqpLiquidityRequest {\n  sourceAccount: string\n}\n\nexport interface QuoteBySourceParams extends IlpPacket.IlqpBySourceRequest {\n  sourceAccount: string\n}\n\nexport interface QuoteByDestinationParams extends IlpPacket.IlqpByDestinationRequest {\n  sourceAccount: string\n}\n\nexport default class RouteBuilder {\n  protected accounts: Accounts\n  protected routingTable: RoutingTable\n  protected backend: RateBackend\n  protected quoter: Quoter\n  protected config: Config\n\n  protected isTrivialRate: boolean\n\n  constructor (deps: reduct.Injector) {\n    this.accounts = deps(Accounts)\n    this.routingTable = deps(RoutingTable)\n    this.backend = deps(RateBackend)\n    this.quoter = deps(Quoter)\n    this.config = deps(Config)\n\n    this.isTrivialRate =\n      this.config.backend === 'one-to-one' &&\n      this.config.spread === 0\n  }\n\n  getNextHop (sourceAccount: string, destinationAccount: string) {\n    const route = this.routingTable.resolve(destinationAccount)\n\n    if (!route) {\n      log.info('no route found for quote. destinationAccount=' + destinationAccount)\n      throw new UnreachableError('no route found. to=' + destinationAccount)\n    }\n\n    if (!this.config.reflectPayments && sourceAccount === route.nextHop) {\n      log.info('refusing to route payments back to sender. sourceAccount=%s destinationAccount=%s', sourceAccount, destinationAccount)\n      throw new UnreachableError('refusing to route payments back to sender. sourceAccount=' + sourceAccount + ' destinationAccount=' + destinationAccount)\n    }\n\n    return route.nextHop\n  }\n\n  async quoteLocal (sourceAccount: string, destinationAccount: string) {\n    if (!this.accounts.getAssetCode(sourceAccount)) {\n      log.info('source account is unavailable. sourceAccount=' + sourceAccount)\n      throw new UnreachableError('no route from source. sourceAccount=' + sourceAccount)\n    }\n\n    const nextHop = this.getNextHop(sourceAccount, destinationAccount)\n\n    if (!this.accounts.getAssetCode(nextHop)) {\n      log.info('next hop is unavailable. nextHop=' + nextHop)\n      throw new UnreachableError('no route to next hop. nextHop=' + nextHop)\n    }\n\n    log.debug('determined next hop. nextHop=' + nextHop)\n\n    const rate = await this.backend.getRate(sourceAccount, nextHop)\n\n    log.debug('determined local rate. rate=' + rate)\n\n    return { nextHop, rate }\n  }\n\n  /**\n   * @param {String} sourceAccount\n   * @param {Object} packet\n   * @param {String} packet.destinationAccount\n   * @param {Number} packet.destinationHoldDuration\n   * @returns {QuoteLiquidityResponse}\n   */\n  async quoteLiquidity (sourceAccount: string, packet: IlpPacket.IlqpLiquidityRequest) {\n    log.info('creating liquidity quote. sourceAccount=%s destinationAccount=%s',\n      sourceAccount, packet.destinationAccount)\n\n    const { nextHop, rate } = await this.quoteLocal(sourceAccount, packet.destinationAccount)\n    const localQuoteExpiry = Date.now() + (this.config.quoteExpiry)\n\n    const localCurve = rateToCurve(rate)\n\n    let liquidityCurve\n    let appliesToPrefix\n    let sourceHoldDuration\n    let expiresAt\n    if (packet.destinationAccount.startsWith(nextHop)) {\n      log.debug('local destination.')\n      liquidityCurve = localCurve\n      appliesToPrefix = nextHop\n      sourceHoldDuration = packet.destinationHoldDuration + this.config.minMessageWindow\n      expiresAt = localQuoteExpiry\n    } else {\n      const quote = await this.quoter.quoteLiquidity(nextHop, packet.destinationAccount)\n      if (!quote) {\n        log.info('no quote found. sourceAccount=%s params=%j', sourceAccount, packet)\n        throw new UnreachableError('no quote found. to=' + packet.destinationAccount)\n      }\n      log.debug('remote destination. quote=%j', quote)\n\n      liquidityCurve = localCurve.join(quote.curve)\n      appliesToPrefix = quote.prefix\n      sourceHoldDuration = packet.destinationHoldDuration + quote.minMessageWindow + this.config.minMessageWindow\n      expiresAt = Math.min(Number(quote.expiry), localQuoteExpiry)\n    }\n\n    this._verifyPluginIsConnected(nextHop)\n    this._validateHoldDurations(sourceHoldDuration, packet.destinationHoldDuration)\n\n    const shiftBy = this._getScaleAdjustment(sourceAccount, nextHop)\n\n    return {\n      // Shifting the curve right by one unit effectively makes it so the client\n      // always sends enough money even despite rounding errors.\n      liquidityCurve: liquidityCurve.shiftX(shiftBy).toBuffer(),\n      // We need to say which prefix this curve applies to. But for that\n      // prefix, the curve must ALWAYS apply because people may cache it.\n      // So we need the shortest prefix of the destination for which this\n      // cached curve will ALWAYS apply.\n      appliesToPrefix: this.routingTable.getShortestUnambiguousPrefix(packet.destinationAccount, appliesToPrefix),\n      sourceHoldDuration,\n      expiresAt: new Date(expiresAt)\n    }\n  }\n\n  _getScaleAdjustment (sourceAccount: string, destinationAccount: string) {\n    const sourceScale = this.accounts.getInfo(sourceAccount).assetScale\n    const destinationScale = this.accounts.getInfo(destinationAccount).assetScale\n    if (sourceScale === destinationScale && this.isTrivialRate) return 0\n    return 1\n  }\n\n  /**\n   * @param {String} sourceAccount\n   * @param {Object} packet\n   * @param {String} packet.destinationAccount\n   * @param {Number} packet.destinationHoldDuration\n   * @param {String} packet.sourceAmount\n   * @returns {QuoteBySourceResponse}\n   */\n  async quoteBySource (sourceAccount: string, packet: IlpPacket.IlqpBySourceRequest) {\n    log.info('creating quote by source amount. sourceAccount=%s destinationAccount=%s sourceAmount=%s',\n      sourceAccount, packet.destinationAccount, packet.sourceAmount)\n\n    if (packet.sourceAmount === '0') {\n      throw new InvalidAmountError('sourceAmount must be positive')\n    }\n\n    const { nextHop, rate } = await this.quoteLocal(sourceAccount, packet.destinationAccount)\n\n    const nextAmount = new BigNumber(packet.sourceAmount).times(rate).integerValue(BigNumber.ROUND_FLOOR).toString()\n    let destinationAmount\n    let sourceHoldDuration\n    if (packet.destinationAccount.startsWith(nextHop)) {\n      log.debug('local destination. destinationAmount=' + nextAmount)\n      destinationAmount = nextAmount\n      sourceHoldDuration = packet.destinationHoldDuration + this.config.minMessageWindow\n    } else {\n      const quote = await this.quoter.quoteLiquidity(nextHop, packet.destinationAccount)\n      if (!quote) {\n        log.info('no quote found. sourceAccount=%s params=%j', sourceAccount, packet)\n        throw new UnreachableError('no quote found. to=' + packet.destinationAccount)\n      }\n      log.debug('remote destination. quote=%j', quote)\n\n      destinationAmount = quote.curve.amountAt(packet.sourceAmount).times(rate).integerValue(BigNumber.ROUND_FLOOR).toString()\n      sourceHoldDuration = packet.destinationHoldDuration + quote.minMessageWindow + this.config.minMessageWindow\n    }\n\n    if (destinationAmount === '0') {\n      throw new InvalidAmountError('quoted destination is lower than minimum amount allowed.')\n    }\n\n    this._verifyPluginIsConnected(sourceAccount)\n    this._verifyPluginIsConnected(nextHop)\n    this._validateHoldDurations(sourceHoldDuration, packet.destinationHoldDuration)\n\n    return {\n      destinationAmount,\n      sourceHoldDuration\n    }\n  }\n\n  /**\n   * @param {String} sourceAccount\n   * @param {Object} packet\n   * @param {String} packet.destinationAccount\n   * @param {Number} packet.destinationHoldDuration\n   * @param {String} packet.destinationAmount\n   * @returns {QuoteByDestinationResponse}\n   */\n  async quoteByDestination (sourceAccount: string, packet: IlpPacket.IlqpByDestinationRequest) {\n    log.info('creating quote by destination amount. sourceAccount=%s destinationAccount=%s destinationAmount=%s',\n      sourceAccount, packet.destinationAccount, packet.destinationAmount)\n\n    if (packet.destinationAmount === '0') {\n      throw new InvalidAmountError('destinationAmount must be positive')\n    }\n\n    const { nextHop, rate } = await this.quoteLocal(sourceAccount, packet.destinationAccount)\n\n    let nextHopAmount\n    let nextHopHoldDuration\n    if (packet.destinationAccount.startsWith(nextHop)) {\n      log.debug('local destination.')\n      nextHopAmount = packet.destinationAmount\n      nextHopHoldDuration = packet.destinationHoldDuration\n    } else {\n      const quote = await this.quoter.quoteLiquidity(nextHop, packet.destinationAccount)\n      if (!quote) {\n        log.info('no quote found. sourceAccount=%s params=%j', sourceAccount, packet)\n        throw new UnreachableError('no quote found. to=' + packet.destinationAccount)\n      }\n      log.debug('remote destination. quote=%j', quote)\n\n      nextHopAmount = quote.curve.amountReverse(packet.destinationAmount).toString()\n      nextHopHoldDuration = packet.destinationHoldDuration + quote.minMessageWindow\n    }\n\n    const sourceAmount = new BigNumber(nextHopAmount).div(rate).integerValue(BigNumber.ROUND_CEIL).toString()\n    const sourceHoldDuration = nextHopHoldDuration + this.config.minMessageWindow\n    if (sourceAmount === '0') {\n      throw new InvalidAmountError('Quoted source is lower than minimum amount allowed')\n    }\n    this._verifyPluginIsConnected(sourceAccount)\n    this._verifyPluginIsConnected(nextHop)\n    this._validateHoldDurations(sourceHoldDuration, packet.destinationHoldDuration)\n    return {\n      sourceAmount,\n      sourceHoldDuration\n    }\n  }\n\n  /**\n   * @typedef {Object} NextHopPacketInfo\n   * @property {string} nextHop Address of the next peer to forward the packet to\n   * @property {Buffer} nextHopPacket Outgoing packet\n   */\n\n  /**\n   * Get next ILP prepare packet.\n   *\n   * Given a previous ILP prepare packet, returns the next ILP prepare packet in\n   * the chain.\n   *\n   * @param {string} sourceAccount ILP address of our peer who sent us the packet\n   * @param {IlpPrepare} sourcePacket (Parsed packet that we received\n   * @returns {NextHopPacketInfo} Account and packet for next hop\n   */\n  async getNextHopPacket (sourceAccount: string, sourcePacket: IlpPacket.IlpPrepare) {\n    const {\n      amount,\n      executionCondition,\n      expiresAt,\n      destination,\n      data\n    } = sourcePacket\n\n    log.info(\n      'constructing next hop packet. sourceAccount=%s sourceAmount=%s destination=%s',\n      sourceAccount, amount, destination\n    )\n\n    if (destination.length < 1) {\n      throw new InvalidPacketError('missing destination.')\n    }\n\n    const route = this.routingTable.resolve(destination)\n\n    if (!route) {\n      log.info('could not find route for transfer. sourceAccount=%s sourceAmount=%s destinationAccount=%s', sourceAccount, amount, destination)\n      throw new UnreachableError('no route found. source=' + sourceAccount + ' destination=' + destination)\n    }\n\n    const nextHop = route.nextHop\n\n    log.debug('determined next hop. nextHop=%s', nextHop)\n\n    const rate = await this.backend.getRate(sourceAccount, nextHop)\n\n    log.debug('determined local rate. rate=%s', rate)\n\n    this._verifyPluginIsConnected(nextHop)\n\n    const nextAmount = new BigNumber(amount).times(rate).integerValue(BigNumber.ROUND_FLOOR)\n\n    return {\n      nextHop,\n      nextHopPacket: {\n        amount: nextAmount.toString(),\n        expiresAt: this._getDestinationExpiry(expiresAt),\n        executionCondition,\n        destination,\n        data\n      }\n    }\n  }\n\n  // TODO: include the expiry duration in the quote logic\n  _validateHoldDurations (sourceHoldDuration: number, destinationHoldDuration: number) {\n    // Check destination_expiry_duration\n    if (destinationHoldDuration > this.config.maxHoldTime) {\n      throw new BadRequestError('destination expiry duration ' +\n        'is too long. destinationHoldDuration=' + destinationHoldDuration +\n        ' maxHoldTime=' + this.config.maxHoldTime)\n    }\n\n    // Check difference between destination_expiry_duration and source_expiry_duration\n    if (sourceHoldDuration - destinationHoldDuration < this.config.minMessageWindow) {\n      throw new BadRequestError('the difference between the ' +\n        'destination expiry duration and the source expiry duration ' +\n        'is insufficient to ensure that we can execute the ' +\n        'source transfers.')\n    }\n  }\n\n  _getDestinationExpiry (sourceExpiry: Date) {\n    if (!sourceExpiry) {\n      throw new TypeError('source expiry must be a Date')\n    }\n    const sourceExpiryTime = sourceExpiry.getTime()\n\n    if (sourceExpiryTime < Date.now()) {\n      throw new InsufficientTimeoutError('source transfer has already expired. sourceExpiry=' + sourceExpiry.toISOString() + ' currentTime=' + (new Date().toISOString()))\n    }\n\n    // We will set the next transfer's expiry based on the source expiry and our\n    // minMessageWindow, but cap it at our maxHoldTime.\n    const destinationExpiryTime = Math.min(sourceExpiryTime - this.config.minMessageWindow, Date.now() + this.config.maxHoldTime)\n\n    if ((destinationExpiryTime - Date.now()) < this.config.minMessageWindow) {\n      throw new InsufficientTimeoutError('source transfer expires too soon to complete payment. actualSourceExpiry=' + sourceExpiry.toISOString() + ' requiredSourceExpiry=' + (new Date(Date.now() + 2 * this.config.minMessageWindow).toISOString()) + ' currentTime=' + (new Date().toISOString()))\n    }\n\n    return new Date(destinationExpiryTime)\n  }\n\n  _verifyPluginIsConnected (account: string) {\n    if (!this.accounts.getPlugin(account).isConnected()) {\n      throw new PeerUnreachableError('no connection to account. account=' + account)\n    }\n  }\n}\n"]}