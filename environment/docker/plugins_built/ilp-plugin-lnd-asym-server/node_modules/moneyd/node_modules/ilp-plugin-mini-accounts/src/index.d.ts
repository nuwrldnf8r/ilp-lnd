/// <reference types="node" />
import * as WebSocket from 'ws';
import AbstractBtpPlugin, * as BtpPlugin from 'ilp-plugin-btp';
import * as ILDCP from 'ilp-protocol-ildcp';
import * as IlpPacket from 'ilp-packet';
declare const StoreWrapper: any;
import { Store, StoreWrapper } from './types';
import { IncomingMessage } from 'http';
export { BtpSubProtocol } from 'ilp-plugin-btp';
interface Logger {
    info(...msg: any[]): void;
    warn(...msg: any[]): void;
    error(...msg: any[]): void;
    debug(...msg: any[]): void;
    trace(...msg: any[]): void;
}
export declare type Protocol = {
    protocolName: string;
    contentType: number;
    data: Buffer;
};
export interface BtpData {
    data: {
        protocolData: Protocol[];
    };
    requestId: number;
}
export default class Plugin extends AbstractBtpPlugin {
    static version: number;
    private _wsOpts;
    protected _currencyScale: number;
    private _debugHostIldcpInfo?;
    protected _log: Logger;
    private _trace;
    private _connections;
    private _allowedOrigins;
    protected _store?: StoreWrapper;
    private _hostIldcpInfo;
    protected _prefix: string;
    protected _handleCustomData: (from: string, btpPacket: BtpPlugin.BtpPacket) => Promise<BtpPlugin.BtpSubProtocol[]>;
    protected _handlePrepareResponse: (destination: string, parsedIlpResponse: IlpPacket.IlpPacket, preparePacket: IlpPacket.IlpPacket) => void;
    constructor(opts: {
        port?: number;
        wsOpts?: WebSocket.ServerOptions;
        currencyScale?: number;
        debugHostIldcpInfo?: ILDCP.IldcpResponse;
        allowedOrigins?: string[];
        _store?: Store;
    }, { log, store }?: {
        log?: Logger;
        store?: Store;
    });
    protected _preConnect(): Promise<void>;
    protected _connect(address: string, authPacket: BtpData, opts: {
        ws: WebSocket;
        req: IncomingMessage;
    }): Promise<void>;
    protected _close(account: string, err?: Error): Promise<void>;
    protected _sendPrepare(destination: string, parsedPacket: IlpPacket.IlpPacket): void;
    ilpAddressToAccount(ilpAddress: string): string;
    connect(): Promise<void>;
    disconnect(): Promise<void>;
    isConnected(): boolean;
    sendData(buffer: Buffer): Promise<Buffer>;
    protected _handleData(from: string, btpPacket: BtpPlugin.BtpPacket): Promise<BtpPlugin.BtpSubProtocol[]>;
    protected _handleOutgoingBtpPacket(to: string, btpPacket: BtpPlugin.BtpPacket): Promise<void>;
    private _addConnection;
    private _removeConnection;
}
