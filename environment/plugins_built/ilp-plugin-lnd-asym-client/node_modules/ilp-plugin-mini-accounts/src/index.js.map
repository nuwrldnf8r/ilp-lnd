{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":"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","sourcesContent":["import * as crypto from 'crypto'\nconst BtpPacket = require('btp-packet')\nimport * as WebSocket from 'ws'\nimport * as assert from 'assert'\nimport AbstractBtpPlugin, * as BtpPlugin from 'ilp-plugin-btp'\nimport * as ILDCP from 'ilp-protocol-ildcp'\nimport * as IlpPacket from 'ilp-packet'\nconst { Errors } = IlpPacket\nconst StoreWrapper = require('ilp-store-wrapper')\nimport OriginWhitelist from './lib/origin-whitelist'\nimport Token from './token'\nimport { Store, StoreWrapper } from './types'\nconst createLogger = require('ilp-logger')\nimport { IncomingMessage } from 'http'\n\nexport { BtpSubProtocol } from 'ilp-plugin-btp'\n\nconst DEBUG_NAMESPACE = 'ilp-plugin-mini-accounts'\n\nfunction tokenToAccount (token: string): string {\n  return BtpPacket.base64url(crypto.createHash('sha256').update(token).digest())\n}\n\ninterface Logger {\n  info (...msg: any[]): void\n  warn (...msg: any[]): void\n  error (...msg: any[]): void\n  debug (...msg: any[]): void\n  trace (...msg: any[]): void\n}\n\nexport type Protocol = {\n  protocolName: string\n  contentType: number\n  data: Buffer\n}\n\nexport interface BtpData {\n  data: {\n    protocolData: Protocol[]\n  }\n  requestId: number\n}\n\n/* tslint:disable-next-line:no-empty */\nfunction noopTrace (...msg: any[]): void { }\n\nexport default class Plugin extends AbstractBtpPlugin {\n  static version = 2\n\n  private _wsOpts: WebSocket.ServerOptions\n  protected _currencyScale: number\n  private _debugHostIldcpInfo?: ILDCP.IldcpResponse\n  protected _log: Logger\n  private _trace: (...msg: any[]) => void\n  private _connections: Map<string, Set<WebSocket>> = new Map()\n  private _allowedOrigins: OriginWhitelist\n  protected _store?: StoreWrapper\n\n  private _hostIldcpInfo: ILDCP.IldcpResponse\n  protected _prefix: string\n  // These can be overridden.\n  // TODO can this be overridden via `extends`??\n  protected _handleCustomData: (from: string, btpPacket: BtpPlugin.BtpPacket) => Promise<BtpPlugin.BtpSubProtocol[]>\n  protected _handlePrepareResponse: (destination: string, parsedIlpResponse: IlpPacket.IlpPacket, preparePacket: IlpPacket.IlpPacket) => void\n\n  constructor (opts: {\n    port?: number,\n    wsOpts?: WebSocket.ServerOptions,\n    currencyScale?: number,\n    debugHostIldcpInfo?: ILDCP.IldcpResponse,\n    allowedOrigins?: string[],\n    _store?: Store\n  }, { log, store }: {\n    log?: Logger,\n    store?: Store\n  } = {}) {\n    super({})\n    const defaultPort = opts.port || 3000\n    this._wsOpts = opts.wsOpts || { port: defaultPort }\n    this._currencyScale = opts.currencyScale || 9\n    this._debugHostIldcpInfo = opts.debugHostIldcpInfo\n\n    this._log = log || createLogger(DEBUG_NAMESPACE)\n    this._log.trace = this._log.trace || noopTrace\n\n    this._allowedOrigins = new OriginWhitelist(opts.allowedOrigins || [])\n\n    if (store || opts._store) {\n      this._store = new StoreWrapper(store || opts._store)\n    }\n  }\n\n  /* tslint:disable:no-empty */\n  // These can be overridden.\n  protected async _preConnect (): Promise<void> {}\n  // FIXME: right now plugin-btp and plugin-mini-accounts use different signatures\n  // for _connect -- ideally mini-accounts would use a different function name, but\n  // this is as close as it can get without being a breaking change.\n  // @ts-ignore\n  protected async _connect (address: string, authPacket: BtpData, opts: {\n    ws: WebSocket,\n    req: IncomingMessage\n  }): Promise<void> {}\n  protected async _close (account: string, err?: Error): Promise<void> {}\n  protected _sendPrepare (destination: string, parsedPacket: IlpPacket.IlpPacket): void {}\n  /* tslint:enable:no-empty */\n\n  ilpAddressToAccount (ilpAddress: string): string {\n    if (ilpAddress.substr(0, this._prefix.length) !== this._prefix) {\n      throw new Error('ILP address (' + ilpAddress + ') must start with prefix (' + this._prefix + ')')\n    }\n\n    return ilpAddress.substr(this._prefix.length).split('.')[0]\n  }\n\n  async connect (): Promise<void> {\n    if (this._wss) return\n\n    if (this._debugHostIldcpInfo) {\n      this._hostIldcpInfo = this._debugHostIldcpInfo\n    } else if (this._dataHandler) {\n      this._hostIldcpInfo = await ILDCP.fetch(this._dataHandler.bind(this))\n    } else {\n      throw new Error('no request handler registered')\n    }\n\n    this._prefix = this._hostIldcpInfo.clientAddress + '.'\n\n    if (this._preConnect) {\n      try {\n        await this._preConnect()\n      } catch (err) {\n        this._log.debug(`Error on _preConnect. Reason is: ${err.message}`)\n        throw new Error('Failed to connect')\n      }\n    }\n\n    this._log.info('listening on port ' + this._wsOpts.port)\n    const wss = this._wss = new WebSocket.Server(this._wsOpts)\n    wss.on('connection', (wsIncoming, req) => {\n      this._log.trace('got connection')\n      if (typeof req.headers.origin === 'string' && !this._allowedOrigins.isOk(req.headers.origin)) {\n        this._log.debug(`Closing a websocket connection received from a browser. Origin is ${req.headers.origin}`)\n        this._log.debug('If you are running moneyd, you may allow this origin with the flag --allow-origin.' +\n          ' Run moneyd --help for details.')\n        wsIncoming.close()\n        return\n      }\n\n      let token: string\n      let account: string\n\n      const closeHandler = (error?: Error) => {\n        this._log.debug('incoming ws closed. error=', error)\n        if (account) this._removeConnection(account, wsIncoming)\n        if (this._close) {\n          this._close(this._prefix + account, error)\n            .catch(e => {\n              this._log.debug('error during custom close handler. error=', e)\n            })\n        }\n      }\n\n      wsIncoming.on('close', closeHandler)\n      wsIncoming.on('error', closeHandler)\n\n      // The first message must be an auth packet\n      // with the macaroon as the auth_token\n      let authPacket: BtpPlugin.BtpPacket\n      wsIncoming.once('message', async (binaryAuthMessage) => {\n        try {\n          authPacket = BtpPacket.deserialize(binaryAuthMessage)\n          assert.strictEqual(authPacket.type, BtpPacket.TYPE_MESSAGE, 'First message sent over BTP connection must be auth packet')\n          assert(authPacket.data.protocolData.length >= 2, 'Auth packet must have auth and auth_token subprotocols')\n          assert.strictEqual(authPacket.data.protocolData[0].protocolName, 'auth', 'First subprotocol must be auth')\n          for (let subProtocol of authPacket.data.protocolData) {\n            if (subProtocol.protocolName === 'auth_token') {\n              // TODO: Do some validation on the token\n              token = subProtocol.data.toString()\n              account = account || tokenToAccount(token)\n              this._addConnection(account, wsIncoming)\n            } else if (subProtocol.protocolName === 'auth_username') {\n              if (this._store) {\n                account = subProtocol.data.toString()\n              }\n            }\n          }\n          assert(token, 'auth_token subprotocol is required')\n\n          this._log.trace('got auth info. token=' + token, 'account=' + account)\n          if (this._store) {\n            const storedToken = await Token.load({ account, store: this._store })\n            const receivedToken = new Token({ account, token, store: this._store })\n            if (storedToken) {\n              if (!storedToken.equal(receivedToken)) {\n                throw new Error('incorrect token for account.' +\n                  ' account=' + account +\n                  ' token=' + token)\n              }\n            } else {\n              receivedToken.save()\n            }\n          }\n\n          if (this._connect) {\n            await this._connect(this._prefix + account, authPacket, {\n              ws: wsIncoming,\n              req\n            })\n          }\n\n          wsIncoming.send(BtpPacket.serializeResponse(authPacket.requestId, []))\n        } catch (err) {\n          if (authPacket) {\n            this._log.debug('not accepted error during auth. error=', err)\n            const errorResponse = BtpPacket.serializeError({\n              code: 'F00',\n              name: 'NotAcceptedError',\n              data: err.message || err.name,\n              triggeredAt: new Date().toISOString()\n            }, authPacket.requestId, [])\n            wsIncoming.send(errorResponse) // TODO throws error \"not opened\"\n          }\n          wsIncoming.close()\n          return\n        }\n\n        this._log.trace('connection authenticated')\n\n        wsIncoming.on('message', async (binaryMessage) => {\n          let btpPacket\n          try {\n            btpPacket = BtpPacket.deserialize(binaryMessage)\n          } catch (err) {\n            wsIncoming.close()\n          }\n          this._log.trace(`account ${account}: processing btp packet ${JSON.stringify(btpPacket)}`)\n          try {\n            this._log.trace('packet is authorized, forwarding to host')\n            await this._handleIncomingBtpPacket(this._prefix + account, btpPacket)\n          } catch (err) {\n            this._log.debug('btp packet not accepted', err)\n            const errorResponse = BtpPacket.serializeError({\n              code: 'F00',\n              name: 'NotAcceptedError',\n              triggeredAt: new Date().toISOString(),\n              data: err.message\n            }, btpPacket.requestId, [])\n            wsIncoming.send(errorResponse)\n          }\n        })\n      })\n    })\n  }\n\n  async disconnect () {\n    if (this._disconnect) {\n      await this._disconnect()\n    }\n\n    if (this._wss) {\n      const wss = this._wss\n      await new Promise((resolve) => wss.close(resolve))\n      this._wss = null\n    }\n  }\n\n  isConnected () {\n    return !!this._wss\n  }\n\n  async sendData (buffer: Buffer): Promise<Buffer> {\n    const parsedPacket = IlpPacket.deserializeIlpPacket(buffer)\n\n    let destination\n    let isPrepare = false\n    switch (parsedPacket.type) {\n      case IlpPacket.Type.TYPE_ILP_PAYMENT:\n      case IlpPacket.Type.TYPE_ILP_FORWARDED_PAYMENT:\n        destination = parsedPacket.data['account']\n        break\n      case IlpPacket.Type.TYPE_ILP_PREPARE:\n        isPrepare = true\n        destination = parsedPacket.data['destination']\n        if (this._sendPrepare) {\n          this._sendPrepare(destination, parsedPacket)\n        }\n        break\n      case IlpPacket.Type.TYPE_ILQP_LIQUIDITY_REQUEST:\n      case IlpPacket.Type.TYPE_ILQP_BY_SOURCE_REQUEST:\n      case IlpPacket.Type.TYPE_ILQP_BY_DESTINATION_REQUEST:\n        destination = parsedPacket.data['destinationAccount']\n        break\n      default:\n        throw new Error('can\\'t route packet with no destination. type=' + parsedPacket.type)\n    }\n\n    if (destination === 'peer.config') {\n      return ILDCP.serializeIldcpResponse(this._hostIldcpInfo)\n    }\n\n    if (!destination.startsWith(this._prefix)) {\n      throw new Error(`can't route packet that is not meant for one of my clients. destination=${destination} prefix=${this._prefix}`)\n    }\n\n    const response = await this._call(destination, {\n      type: BtpPacket.TYPE_MESSAGE,\n      requestId: crypto.randomBytes(4).readUInt32BE(0),\n      data: { protocolData: [{\n        protocolName: 'ilp',\n        contentType: BtpPacket.MIME_APPLICATION_OCTET_STREAM,\n        data: buffer\n      }] }\n    })\n\n    const ilpResponse = response.protocolData.filter(p => p.protocolName === 'ilp')[0]\n    const parsedIlpResponse = IlpPacket.deserializeIlpPacket(ilpResponse.data)\n\n    if (parsedIlpResponse.type === IlpPacket.Type.TYPE_ILP_FULFILL) {\n      const executionCondition = parsedPacket.data['executionCondition'] || Buffer.alloc(0)\n      /* tslint:disable-next-line:no-unnecessary-type-assertion */\n      const fulfillResponse = parsedIlpResponse.data as IlpPacket.IlpFulfill\n      if (!crypto.createHash('sha256')\n        .update(fulfillResponse.fulfillment)\n        .digest()\n        .equals(executionCondition)) {\n        return IlpPacket.errorToReject(this._hostIldcpInfo.clientAddress,\n          new Errors.WrongConditionError(\n            'condition and fulfillment don\\'t match. ' +\n            `condition=${executionCondition.toString('hex')} ` +\n            `fulfillment=${fulfillResponse.fulfillment.toString('hex')}`))\n      }\n    }\n\n    if (isPrepare && this._handlePrepareResponse) {\n      try {\n        this._handlePrepareResponse(destination, parsedIlpResponse, parsedPacket)\n      } catch (e) {\n        return IlpPacket.errorToReject(this._hostIldcpInfo.clientAddress, e)\n      }\n    }\n\n    return ilpResponse\n      ? ilpResponse.data\n      : Buffer.alloc(0)\n  }\n\n  protected async _handleData (from: string, btpPacket: BtpPlugin.BtpPacket): Promise<BtpPlugin.BtpSubProtocol[]> {\n    const { ilp } = this.protocolDataToIlpAndCustom(btpPacket.data)\n\n    if (ilp) {\n      const parsedPacket = IlpPacket.deserializeIlpPacket(ilp)\n\n      if (parsedPacket.data['destination'] === 'peer.config') {\n        this._log.trace('responding to ILDCP request. clientAddress=%s', from)\n        return [{\n          protocolName: 'ilp',\n          contentType: BtpPacket.MIME_APPLICATION_OCTET_STREAM,\n          data: await ILDCP.serve({\n            requestPacket: ilp,\n            handler: () => ({\n              ...this._hostIldcpInfo,\n              clientAddress: from\n            }),\n            serverAddress: this._hostIldcpInfo.clientAddress\n          })\n        }]\n      }\n    }\n\n    if (this._handleCustomData) {\n      this._log.trace('passing non-ILDCP data to custom handler')\n      return this._handleCustomData(from, btpPacket)\n    }\n\n    if (!ilp) {\n      this._log.debug('invalid packet, no ilp protocol data. from=%s', from)\n      throw new Error('invalid packet, no ilp protocol data.')\n    }\n\n    if (!this._dataHandler) {\n      throw new Error('no request handler registered')\n    }\n\n    const response = await this._dataHandler(ilp)\n    return this.ilpAndCustomToProtocolData({ ilp: response })\n  }\n\n  protected async _handleOutgoingBtpPacket (to: string, btpPacket: BtpPlugin.BtpPacket) {\n    if (!to.startsWith(this._prefix)) {\n      throw new Error(`invalid destination, must start with prefix. destination=${to} prefix=${this._prefix}`)\n    }\n\n    const account = this.ilpAddressToAccount(to)\n    const connections = this._connections.get(account)\n\n    if (!connections) {\n      throw new Error('No clients connected for account ' + account)\n    }\n\n    Array.from(connections).map(wsIncoming => {\n      const result = new Promise(resolve => wsIncoming.send(BtpPacket.serialize(btpPacket), resolve))\n\n      result.catch(err => {\n        const errorInfo = (typeof err === 'object' && err.stack) ? err.stack : String(err)\n        this._log.debug('unable to send btp message to client: ' + errorInfo, 'btp packet:', JSON.stringify(btpPacket))\n      })\n    })\n  }\n\n  private _addConnection (account: string, wsIncoming: WebSocket) {\n    let connections = this._connections.get(account)\n    if (!connections) {\n      this._connections.set(account, connections = new Set())\n    }\n    connections.add(wsIncoming)\n  }\n\n  private _removeConnection (account: string, wsIncoming: WebSocket) {\n    const connections = this._connections.get(account)\n    if (!connections) return\n    connections.delete(wsIncoming)\n    if (connections.size === 0) {\n      this._connections.delete(account)\n    }\n  }\n}\n"]}