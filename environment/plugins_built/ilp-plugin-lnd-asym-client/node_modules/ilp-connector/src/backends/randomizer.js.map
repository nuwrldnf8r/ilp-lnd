{"version":3,"file":"randomizer.js","sourceRoot":"","sources":["randomizer.ts"],"names":[],"mappings":";;AAAA,+CAAoC;AAIpC,uCAAsD;AACtD,MAAM,GAAG,GAAG,YAAY,CAAC,oBAAoB,CAAC,CAAA;AAU9C;IAUE,YAAa,IAAuB,EAAE,GAAoB;QACxD,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,IAAI,CAAC,CAAA;QAC9B,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,IAAI,GAAG,CAAA;QACtC,IAAI,CAAC,OAAO,GAAG,GAAG,CAAC,OAAO,CAAA;QAG1B,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC,CAAA;QAEtD,GAAG,CAAC,IAAI,CAAC,kDAAkD,EAAE,IAAI,CAAC,SAAS,CAAC,CAAA;IAC9E,CAAC;IAKD,KAAK,CAAC,OAAO;IAEb,CAAC;IAWD,KAAK,CAAC,OAAO,CAAE,aAAqB,EAAE,kBAA0B;QAC9D,MAAM,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,CAAA;QAC9C,MAAM,eAAe,GAAG,IAAI,CAAC,OAAO,CAAC,kBAAkB,CAAC,CAAA;QAExD,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;YAChB,GAAG,CAAC,IAAI,CAAC,+DAA+D,EAAE,aAAa,CAAC,CAAA;YACxF,MAAM,IAAI,KAAK,CAAC,6DAA6D,GAAG,aAAa,CAAC,CAAA;QAChG,CAAC;QACD,EAAE,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC;YACrB,GAAG,CAAC,IAAI,CAAC,oEAAoE,EAAE,kBAAkB,CAAC,CAAA;YAClG,MAAM,IAAI,KAAK,CAAC,kEAAkE,GAAG,kBAAkB,CAAC,CAAA;QAC1G,CAAC;QAED,MAAM,SAAS,GAAG,eAAe,CAAC,UAAU,GAAG,UAAU,CAAC,UAAU,CAAA;QAOpE,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,IAAI,CAAC,SAAS,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAA;QAQtF,MAAM,IAAI,GAAG,IAAI,sBAAS,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,WAAW,CAAC,EAAE,CAAC,CAAA;QAEtG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;IACrB,CAAC;IAOD,aAAa;QACX,MAAM,CAAC,OAAO,CAAC,OAAO,EAAE,CAAA;IAC1B,CAAC;CACF;AA9ED,oCA8EC","sourcesContent":["import BigNumber from 'bignumber.js'\nimport { AccountInfo } from '../types/accounts'\nimport { BackendInstance, BackendServices } from '../types/backend'\n\nimport { create as createLogger } from '../common/log'\nconst log = createLogger('randomizer-backend')\n\nexport interface RandomizerOptions {\n  spread: number\n  variation: number\n}\n\n/**\n * Backend which charges no spread and trades everything one-to-one.\n */\nexport default class RandomizerBackend implements BackendInstance {\n  protected spread: number\n  protected variation: number\n  protected getInfo: (accountId: string) => AccountInfo | undefined\n\n  /**\n   * Constructor.\n   *\n   * @param {Integer} opts.spread The spread we will use to mark up the FX rates\n   */\n  constructor (opts: RandomizerOptions, api: BackendServices) {\n    this.spread = opts.spread || 0\n    this.variation = opts.variation || 0.1\n    this.getInfo = api.getInfo\n\n    // Variation should be in the range 0 to 1\n    this.variation = Math.min(Math.abs(this.variation), 1)\n\n    log.warn('(!!!) using the randomizer backend. variation=%s', this.variation)\n  }\n\n  /**\n   * Nothing to do since this backend is totally static.\n   */\n  async connect () {\n    // Nothing to do\n  }\n\n  /**\n   * Get a rate for the given parameters.\n   *\n   * The one-to-one backend applies an exchange of 1, however, it will subtract\n   * the spread if a spread is set in the configuration.\n   *\n   * @param sourceAccount The account ID of the previous party\n   * @param destinationAccount The account ID of the next hop party\n   */\n  async getRate (sourceAccount: string, destinationAccount: string) {\n    const sourceInfo = this.getInfo(sourceAccount)\n    const destinationInfo = this.getInfo(destinationAccount)\n\n    if (!sourceInfo) {\n      log.warn('unable to fetch account info for source account. accountId=%s', sourceAccount)\n      throw new Error('unable to fetch account info for source account. accountId=' + sourceAccount)\n    }\n    if (!destinationInfo) {\n      log.warn('unable to fetch account info for destination account. accountId=%s', destinationAccount)\n      throw new Error('unable to fetch account info for destination account. accountId=' + destinationAccount)\n    }\n\n    const scaleDiff = destinationInfo.assetScale - sourceInfo.assetScale\n\n    // Math.random returns a number in the range [0, 1), so\n    // note that Math.random() - 0.5 is NOT the same as\n    // 0.5 - Math.random()\n    //\n    // By using\n    const randomness = Math.max((0.5 - Math.random()) * this.variation * 2, -1).toFixed(5)\n\n    // The spread is subtracted from the rate when going in either direction,\n    // so that the DestinationAmount always ends up being slightly less than\n    // the (equivalent) SourceAmount -- regardless of which of the 2 is fixed:\n    //\n    //   SourceAmount * (1 + Random - Spread) = DestinationAmount\n    //\n    const rate = new BigNumber(1).plus(randomness).minus(this.spread).shiftedBy(scaleDiff).toPrecision(15)\n\n    return Number(rate)\n  }\n\n  /**\n   * This method is called to allow statistics to be collected by the backend.\n   *\n   * The randomizer backend does not support this functionality.\n   */\n  submitPayment () {\n    return Promise.resolve()\n  }\n}\n"]}