"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const IlpPacket = require("ilp-packet");
const accounts_1 = require("./accounts");
const config_1 = require("./config");
const liquidity_curve_1 = require("../routing/liquidity-curve");
const prefix_map_1 = require("../routing/prefix-map");
const log_1 = require("../common/log");
const log = log_1.create('quoter');
const { InternalError } = IlpPacket.Errors;
const DESTINATION_HOLD_DURATION = 5000;
class Quoter {
    constructor(deps) {
        this.accounts = deps(accounts_1.default);
        this.quoteExpiryDuration = deps(config_1.default).quoteExpiry;
        this.cache = new prefix_map_1.default();
    }
    async quoteLiquidity(nextHop, destinationAccount) {
        const cachedCurve = this.cache.resolve(destinationAccount);
        if (cachedCurve) {
            if (cachedCurve.expiry < Date.now()) {
                log.debug('cleaning up expired cached curve. prefix=%s expiry=%s', cachedCurve.prefix, new Date(cachedCurve.expiry).toISOString());
                this.cache.delete(cachedCurve.prefix);
            }
            else {
                log.debug('returning cached curve. prefix=%s', cachedCurve.prefix);
                return cachedCurve;
            }
        }
        const quoteRequestPacket = IlpPacket.serializeIlqpLiquidityRequest({
            destinationAccount: destinationAccount,
            destinationHoldDuration: DESTINATION_HOLD_DURATION
        });
        const plugin = this.accounts.getPlugin(nextHop);
        log.debug('sending quote request packet. connector=%s', nextHop);
        const quoteResponsePacket = await plugin.sendData(quoteRequestPacket);
        if (quoteResponsePacket[0] === IlpPacket.Type.TYPE_ILQP_LIQUIDITY_RESPONSE) {
            const data = IlpPacket.deserializeIlqpLiquidityResponse(quoteResponsePacket);
            return {
                curve: new liquidity_curve_1.default(data.liquidityCurve),
                prefix: data.appliesToPrefix,
                expiry: new Date(data.expiresAt),
                minMessageWindow: data.sourceHoldDuration - DESTINATION_HOLD_DURATION
            };
        }
        else {
            throw new InternalError('remote quote error.');
        }
    }
    cacheCurve({ prefix, curve, expiry, minMessageWindow }) {
        log.debug('caching curve. prefix=%s expiry=%s minMessageWindow=%s', prefix, expiry, minMessageWindow);
        this.cache.insert(prefix, {
            prefix,
            curve,
            expiry,
            minMessageWindow
        });
    }
}
exports.default = Quoter;
//# sourceMappingURL=quoter.js.map