{"version":3,"file":"deduplicate.js","sourceRoot":"","sources":["deduplicate.ts"],"names":[],"mappings":"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","sourcesContent":["import { createHash } from 'crypto'\nimport * as IlpPacket from 'ilp-packet'\nimport { Middleware, MiddlewareCallback, Pipelines } from '../types/middleware'\nimport BigNumber from 'bignumber.js'\n\n// Where in the ILP packet does the static data begin (i.e. the data that is not modified hop-to-hop)\nconst STATIC_DATA_OFFSET = 25 // 8 byte amount + 17 byte expiry date\n\nconst CACHE_CLEANUP_INTERVAL = 30000\nconst PACKET_CACHE_DURATION = 30000\n\ninterface CachedPacket {\n  amount: string,\n  expiresAt: Date,\n  promise: Promise<Buffer>\n}\n\nexport default class DeduplicateMiddleware implements Middleware {\n  private packetCache: Map<string, CachedPacket> = new Map()\n\n  async applyToPipelines (pipelines: Pipelines, accountId: string) {\n    pipelines.startup.insertLast({\n      name: 'deduplicate',\n      method: async (dummy: void, next: MiddlewareCallback<void, void>) => {\n        setInterval(() => this.cleanupCache(), CACHE_CLEANUP_INTERVAL)\n      }\n    })\n\n    pipelines.outgoingData.insertLast({\n      name: 'deduplicate',\n      method: async (data: Buffer, next: MiddlewareCallback<Buffer, Buffer>) => {\n        if (data[0] === IlpPacket.Type.TYPE_ILP_PREPARE) {\n          const { contents } = IlpPacket.deserializeEnvelope(data)\n\n          const index = createHash('sha256')\n            .update(contents.slice(STATIC_DATA_OFFSET))\n            .digest()\n            .slice(0, 16) // 128 bits is enough and saves some memory\n            .toString('base64')\n\n          const { amount, expiresAt } = IlpPacket.deserializeIlpPrepare(data)\n\n          const cachedPacket = this.packetCache.get(index)\n          if (cachedPacket) {\n            // We have seen this packet before, let's check if previous amount and expiresAt were larger\n            if (new BigNumber(cachedPacket.amount).gte(amount) && cachedPacket.expiresAt >= expiresAt) {\n              return cachedPacket.promise\n            }\n          }\n\n          const promise = next(data)\n\n          this.packetCache.set(index, {\n            amount,\n            expiresAt,\n            promise\n          })\n\n          return promise\n        }\n\n        return next(data)\n      }\n    })\n  }\n\n  private cleanupCache () {\n    const now = Date.now()\n    for (const index of this.packetCache.keys()) {\n      const cachedPacket = this.packetCache.get(index)\n      if (!cachedPacket) continue\n      const packetExpiry = cachedPacket.expiresAt.getTime() + PACKET_CACHE_DURATION\n      if (packetExpiry < now) {\n        this.packetCache.delete(index)\n      }\n    }\n  }\n}\n"]}