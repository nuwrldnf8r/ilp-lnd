{"version":3,"file":"expire.js","sourceRoot":"","sources":["expire.ts"],"names":[],"mappings":";;AAAA,uCAAsD;AACtD,MAAM,GAAG,GAAG,YAAY,CAAC,mBAAmB,CAAC,CAAA;AAC7C,wCAAuC;AAEvC,MAAM,EAAE,aAAa,EAAE,GAAG,SAAS,CAAC,MAAM,CAAA;AAE1C;IACE,KAAK,CAAC,gBAAgB,CAAE,SAAoB,EAAE,SAAiB;QAC7D,SAAS,CAAC,YAAY,CAAC,UAAU,CAAC;YAChC,IAAI,EAAE,QAAQ;YACd,MAAM,EAAE,KAAK,EAAE,IAAY,EAAE,IAAwC,EAAE,EAAE;gBACvE,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,SAAS,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC;oBAChD,MAAM,EAAE,kBAAkB,EAAE,SAAS,EAAE,GAAG,SAAS,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAA;oBAE/E,MAAM,QAAQ,GAAG,SAAS,CAAC,OAAO,EAAE,GAAG,IAAI,CAAC,GAAG,EAAE,CAAA;oBAEjD,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,CAAA;oBAE1B,IAAI,OAAO,CAAA;oBACX,MAAM,cAAc,GAAoB,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;wBACtE,OAAO,GAAG,UAAU,CAAC,GAAG,EAAE;4BACxB,GAAG,CAAC,KAAK,CAAC,sCAAsC,EAAE,kBAAkB,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,SAAS,CAAC,WAAW,EAAE,CAAC,CAAA;4BAC7H,MAAM,CAAC,IAAI,aAAa,CAAC,iBAAiB,CAAC,CAAC,CAAA;wBAC9C,CAAC,EAAE,QAAQ,CAAC,CAAA;oBACd,CAAC,CAAC,CAAA;oBAEF,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC;wBAClB,OAAO,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE,GAAG,YAAY,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAA,CAAC,CAAC,CAAC;wBAC9D,cAAc;qBACf,CAAC,CAAA;gBACJ,CAAC;gBAED,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;YACnB,CAAC;SACF,CAAC,CAAA;IACJ,CAAC;CACF;AA9BD,mCA8BC","sourcesContent":["import { create as createLogger } from '../common/log'\nconst log = createLogger('expire-middleware')\nimport * as IlpPacket from 'ilp-packet'\nimport { Middleware, MiddlewareCallback, Pipelines } from '../types/middleware'\nconst { InternalError } = IlpPacket.Errors\n\nexport default class ExpireMiddleware implements Middleware {\n  async applyToPipelines (pipelines: Pipelines, accountId: string) {\n    pipelines.outgoingData.insertLast({\n      name: 'expire',\n      method: async (data: Buffer, next: MiddlewareCallback<Buffer, Buffer>) => {\n        if (data[0] === IlpPacket.Type.TYPE_ILP_PREPARE) {\n          const { executionCondition, expiresAt } = IlpPacket.deserializeIlpPrepare(data)\n\n          const duration = expiresAt.getTime() - Date.now()\n\n          const promise = next(data)\n\n          let timeout\n          const timeoutPromise: Promise<Buffer> = new Promise((resolve, reject) => {\n            timeout = setTimeout(() => {\n              log.debug('packet expired. cond=%s expiresAt=%s', executionCondition.slice(0, 6).toString('base64'), expiresAt.toISOString())\n              reject(new InternalError('packet expired.'))\n            }, duration)\n          })\n\n          return Promise.race([\n            promise.then((data) => { clearTimeout(timeout); return data }),\n            timeoutPromise\n          ])\n        }\n\n        return next(data)\n      }\n    })\n  }\n}\n"]}